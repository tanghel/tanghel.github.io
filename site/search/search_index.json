{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TimeLine Developer","title":"Home"},{"location":"#timeline-developer","text":"","title":"TimeLine Developer"},{"location":"bestpractices/code-smells/","text":"Code smells Principle In computer programming, a code smell is any characteristic in the source code of a program that possibly indicates a deeper problem. Determining what is and is not a code smell is subjective, and varies by language, developer, and development methodology. The term was popularised by Kent Beck on WardsWiki in the late 1990s. Usage of the term increased after it was featured in the book Refactoring: Improving the Design of Existing Code by Martin Fowler. It is also a term used by agile programmers. One way to look at smells is with respect to principles and quality: \"Smells are certain structures in the code that indicate violation of fundamental design principles and negatively impact design quality\". Code smells are usually not bugs; they are not technically incorrect and do not prevent the program from functioning. Instead, they indicate weaknesses in design that may slow down development or increase the risk of bugs or failures in the future. Bad code smells can be an indicator of factors that contribute to technical debt. Robert C. Martin calls a list of code smells a \"value system\" for software craftsmanship. Often the deeper problem hinted at by a code smell can be uncovered when the code is subjected to a short feedback cycle, where it is refactored in small, controlled steps, and the resulting design is examined to see if there are any further code smells that in turn indicate the need for more refactoring. From the point of view of a programmer charged with performing refactoring, code smells are heuristics to indicate when to refactor, and what specific refactoring techniques to use. Thus, a code smell is a driver for refactoring. A 2015 study utilizing automated analysis for half a million source code commits and the manual examination of 9,164 commits determined to exhibit \"code smells\" found that: There exists empirical evidence for the consequences of \"technical debt\", but there exists only anecdotal evidence as to how, when, or why this occurs. \"Common wisdom suggests that urgent maintenance activities and pressure to deliver features while prioritizing time-to-market over code quality are often the causes of such smells\". Referencing controls by string Comparing control by name, although it works exactly like comparing to a control reference, it has one big downside: when the control no longer exists in the xaml file or has been renamed, the code will still compile and thus the module will not continue to work as expected. Bad if (element.Name == tbMATPreis ) { } After switching to reference comparison, when the name of tbMATPreis changes to e.g. tbMatPreis , then the compiler will throw an error, prompting the user to alter the code accordingly. Good if (element == tbMATPreis) { } Referencing columns by index When referencing columns by index, there is the danger that after some time, the order of the columns will be changed, and the intended column at the given index is no longer valid (we may be referncing a different column altogether or even worse, we might get an IndexOutOfRangeException ) Bad this.dgMahng.Columns[1].Visible = false; When referencing column by name, we have the guarantee that we are indeed setting the visibility of the control we intend to change Good this.dgtbMahngZeitraum.Visible = false","title":"Code Smells"},{"location":"bestpractices/code-smells/#code-smells","text":"","title":"Code smells"},{"location":"bestpractices/code-smells/#principle","text":"In computer programming, a code smell is any characteristic in the source code of a program that possibly indicates a deeper problem. Determining what is and is not a code smell is subjective, and varies by language, developer, and development methodology. The term was popularised by Kent Beck on WardsWiki in the late 1990s. Usage of the term increased after it was featured in the book Refactoring: Improving the Design of Existing Code by Martin Fowler. It is also a term used by agile programmers. One way to look at smells is with respect to principles and quality: \"Smells are certain structures in the code that indicate violation of fundamental design principles and negatively impact design quality\". Code smells are usually not bugs; they are not technically incorrect and do not prevent the program from functioning. Instead, they indicate weaknesses in design that may slow down development or increase the risk of bugs or failures in the future. Bad code smells can be an indicator of factors that contribute to technical debt. Robert C. Martin calls a list of code smells a \"value system\" for software craftsmanship. Often the deeper problem hinted at by a code smell can be uncovered when the code is subjected to a short feedback cycle, where it is refactored in small, controlled steps, and the resulting design is examined to see if there are any further code smells that in turn indicate the need for more refactoring. From the point of view of a programmer charged with performing refactoring, code smells are heuristics to indicate when to refactor, and what specific refactoring techniques to use. Thus, a code smell is a driver for refactoring. A 2015 study utilizing automated analysis for half a million source code commits and the manual examination of 9,164 commits determined to exhibit \"code smells\" found that: There exists empirical evidence for the consequences of \"technical debt\", but there exists only anecdotal evidence as to how, when, or why this occurs. \"Common wisdom suggests that urgent maintenance activities and pressure to deliver features while prioritizing time-to-market over code quality are often the causes of such smells\".","title":"Principle"},{"location":"bestpractices/code-smells/#referencing-controls-by-string","text":"Comparing control by name, although it works exactly like comparing to a control reference, it has one big downside: when the control no longer exists in the xaml file or has been renamed, the code will still compile and thus the module will not continue to work as expected. Bad if (element.Name == tbMATPreis ) { } After switching to reference comparison, when the name of tbMATPreis changes to e.g. tbMatPreis , then the compiler will throw an error, prompting the user to alter the code accordingly. Good if (element == tbMATPreis) { }","title":"Referencing controls by string"},{"location":"bestpractices/code-smells/#referencing-columns-by-index","text":"When referencing columns by index, there is the danger that after some time, the order of the columns will be changed, and the intended column at the given index is no longer valid (we may be referncing a different column altogether or even worse, we might get an IndexOutOfRangeException ) Bad this.dgMahng.Columns[1].Visible = false; When referencing column by name, we have the guarantee that we are indeed setting the visibility of the control we intend to change Good this.dgtbMahngZeitraum.Visible = false","title":"Referencing columns by index"},{"location":"bestpractices/general/","text":"General coding style guidelines Naming DO use PascalCasing for class names and method names. public class ClientActivity { public void ClearStatistics() { //... } public void CalculateStatistics() { //... } } DO use camelCasing for method arguments and local variables. public class UserLog { public void Add(LogEvent logEvent) { int itemCount = logEvent.Items.Count; // ... } } DO use PascalCasing for abbreviations 3 characters or more (2 chars are both uppercase) HtmlHelper htmlHelper; FtpTransfer ftpTransfer; UIControl uiControl; DO use predefined type names instead of system type names like Int16, Single, UInt64, etc // Correct string firstName; int lastIndex; bool isSaved; // Avoid String firstName; Int32 lastIndex; Boolean isSaved; DO use implicit type var for local variable declarations. Exception: primitive types (int, string, double, etc) use predefined names. var stream = File.Create(path); var customers = new Dictionary(); // Exceptions int index = 100; string timeSheet; bool isCompleted; DO use noun or noun phrases to name a class. public class Employee { } public class BusinessLocation { } public class DocumentCollection { } DO prefix interfaces with the letter I. Interface names are noun (phrases) or adjectives. public interface IShape { } public interface IShapeCollection { } public interface IGroupable { } DO name source files according to their main classes. Exception: file names with partial classes reflect their source or purpose, e.g. designer, generated, etc. // Located in Task.cs public partial class Task { //... } // Located in Task.generated.cs public partial class Task { //... } DO organize namespaces with a clearly defined structure // Examples namespace Company.Product.Module.SubModule namespace Product.Module.Component namespace Product.Layer.Module.Group DO vertically align curly brackets. // Correct class Program { static void Main(string[] args) { } } DO declare all member variables at the top of a class, with static variables at the very top. // Correct public class Account { public static string BankName; public static decimal Reserves; public string Number {get; set;} public DateTime DateOpened {get; set;} public DateTime DateClosed {get; set;} public decimal Balance {get; set;} // Constructor public Account() { // ... } } DO use singular names for enums. Exception: bit field enums. // Correct public enum Color { Red, Green, Blue, Yellow, Magenta, Cyan } // Exception [Flags] public enum Dockings { None = 0, Top = 1, Right = 2, Bottom = 4, Left = 8 } AVOID using Abbreviations. Exceptions: abbreviations commonly used as names, such as Id, Xml, Ftp, Uri // Correct UserGroup userGroup; Assignment employeeAssignment; // Avoid UserGroup usrGrp; Assignment empAssignment; // Exceptions CustomerId customerId; XmlDocument xmlDocument; FtpHelper ftpHelper; UriPart uriPart; DO NOT explicitly specify a type of an enum or values of enums (except bit fields) // Don't public enum Direction : long { North = 1, East = 2, South = 3, West = 4 } // Correct public enum Direction { North, East, South, West } DO NOT suffix enum names with Enum // Don't public enum CoinEnum { Penny, Nickel, Dime, Quarter, Dollar } // Correct public enum Coin { Penny, Nickel, Dime, Quarter, Dollar } DO NOT use Underscores in identifiers. Exception: you can prefix private static variables with an underscore. // Correct public DateTime clientAppointment; public TimeSpan timeLeft; // Avoid public DateTime client_Appointment; public TimeSpan time_Left; // Exception private DateTime _registrationDate; Formatting Write only one statement per line. Write only one declaration per line. If continuation lines are not indented automatically, indent them one tab stop (four spaces). Add exactly one blank line between method definitions and property definitions. public string MyProperty { get; set; } public virtual void MyMethod(string value) { if (value == null) throw new ArgumentNullException(nameof(value)); var belposRows = tSet.belpos.DefaultViewRows .Where(x = x.projekt_id == BelRow.projekt_id x.GetRowState() != EnumRowState.Deleted); foreach (var belposRow in belposRows) { belposRow.SetRowState(EnumRowState.New); } } public virtual void AnotherMethod(string projektId, dsBel.belposRow belposRow = null) { if (projektId == null) throw new ArgumentNullException(nameof(projektId)); if (projektId.IsNotNullOrEmpty()) { var fibuCobjId = Sql.TrySelectValue( select fibu_cobjid from projekte where id = :projekt , new { projekt = projektId }).ToStringNN(); if (fibuCobjId.IsNotNullOrEmpty()) { if (belposRow == null) { RetrieveBelegFibuKostenobjekt(BelRow, fibuCobjId); } else if (belposRow.fibu_cobjid.IsNullOrEmpty()) { RetrieveBelposFibuKostenobjekt(belposRow, fibuCobjId); } } } }","title":"General"},{"location":"bestpractices/general/#general-coding-style-guidelines","text":"","title":"General coding style guidelines"},{"location":"bestpractices/general/#naming","text":"DO use PascalCasing for class names and method names. public class ClientActivity { public void ClearStatistics() { //... } public void CalculateStatistics() { //... } } DO use camelCasing for method arguments and local variables. public class UserLog { public void Add(LogEvent logEvent) { int itemCount = logEvent.Items.Count; // ... } } DO use PascalCasing for abbreviations 3 characters or more (2 chars are both uppercase) HtmlHelper htmlHelper; FtpTransfer ftpTransfer; UIControl uiControl; DO use predefined type names instead of system type names like Int16, Single, UInt64, etc // Correct string firstName; int lastIndex; bool isSaved; // Avoid String firstName; Int32 lastIndex; Boolean isSaved; DO use implicit type var for local variable declarations. Exception: primitive types (int, string, double, etc) use predefined names. var stream = File.Create(path); var customers = new Dictionary(); // Exceptions int index = 100; string timeSheet; bool isCompleted; DO use noun or noun phrases to name a class. public class Employee { } public class BusinessLocation { } public class DocumentCollection { } DO prefix interfaces with the letter I. Interface names are noun (phrases) or adjectives. public interface IShape { } public interface IShapeCollection { } public interface IGroupable { } DO name source files according to their main classes. Exception: file names with partial classes reflect their source or purpose, e.g. designer, generated, etc. // Located in Task.cs public partial class Task { //... } // Located in Task.generated.cs public partial class Task { //... } DO organize namespaces with a clearly defined structure // Examples namespace Company.Product.Module.SubModule namespace Product.Module.Component namespace Product.Layer.Module.Group DO vertically align curly brackets. // Correct class Program { static void Main(string[] args) { } } DO declare all member variables at the top of a class, with static variables at the very top. // Correct public class Account { public static string BankName; public static decimal Reserves; public string Number {get; set;} public DateTime DateOpened {get; set;} public DateTime DateClosed {get; set;} public decimal Balance {get; set;} // Constructor public Account() { // ... } } DO use singular names for enums. Exception: bit field enums. // Correct public enum Color { Red, Green, Blue, Yellow, Magenta, Cyan } // Exception [Flags] public enum Dockings { None = 0, Top = 1, Right = 2, Bottom = 4, Left = 8 } AVOID using Abbreviations. Exceptions: abbreviations commonly used as names, such as Id, Xml, Ftp, Uri // Correct UserGroup userGroup; Assignment employeeAssignment; // Avoid UserGroup usrGrp; Assignment empAssignment; // Exceptions CustomerId customerId; XmlDocument xmlDocument; FtpHelper ftpHelper; UriPart uriPart; DO NOT explicitly specify a type of an enum or values of enums (except bit fields) // Don't public enum Direction : long { North = 1, East = 2, South = 3, West = 4 } // Correct public enum Direction { North, East, South, West } DO NOT suffix enum names with Enum // Don't public enum CoinEnum { Penny, Nickel, Dime, Quarter, Dollar } // Correct public enum Coin { Penny, Nickel, Dime, Quarter, Dollar } DO NOT use Underscores in identifiers. Exception: you can prefix private static variables with an underscore. // Correct public DateTime clientAppointment; public TimeSpan timeLeft; // Avoid public DateTime client_Appointment; public TimeSpan time_Left; // Exception private DateTime _registrationDate;","title":"Naming"},{"location":"bestpractices/general/#formatting","text":"Write only one statement per line. Write only one declaration per line. If continuation lines are not indented automatically, indent them one tab stop (four spaces). Add exactly one blank line between method definitions and property definitions. public string MyProperty { get; set; } public virtual void MyMethod(string value) { if (value == null) throw new ArgumentNullException(nameof(value)); var belposRows = tSet.belpos.DefaultViewRows .Where(x = x.projekt_id == BelRow.projekt_id x.GetRowState() != EnumRowState.Deleted); foreach (var belposRow in belposRows) { belposRow.SetRowState(EnumRowState.New); } } public virtual void AnotherMethod(string projektId, dsBel.belposRow belposRow = null) { if (projektId == null) throw new ArgumentNullException(nameof(projektId)); if (projektId.IsNotNullOrEmpty()) { var fibuCobjId = Sql.TrySelectValue( select fibu_cobjid from projekte where id = :projekt , new { projekt = projektId }).ToStringNN(); if (fibuCobjId.IsNotNullOrEmpty()) { if (belposRow == null) { RetrieveBelegFibuKostenobjekt(BelRow, fibuCobjId); } else if (belposRow.fibu_cobjid.IsNullOrEmpty()) { RetrieveBelposFibuKostenobjekt(belposRow, fibuCobjId); } } } }","title":"Formatting"},{"location":"documentation/introduction/","text":"Introduction Module Each \u201ecomplete\u201d module has: a Window Handling Object WHO: specifies the behavior of the controls a BusinessObject busObj: data manipulation; direct access to the dataSet (and dataSet fields) at least one DataSet A Window Handling Object defines the behavior of the window itself and of the controls within it. It is the place where the \u201ecall-to-action\u201d happens, i.e. it can respond to event handlers of any type. It responds to various events triggered by the window or by the controls, it holds references to the controls and can modify their properties at any given time. It does not contain business logic functionality; it delegates the functionality to the Business Object. It is the component that is able to handle exceptions and decide how the exception is handled (show message to user, retry, fail silently, etc.) A Business Object is the part of the program that encodes the real-world business rules that determine how data can be created, stored, and changed . It is contrasted with the remainder of the software that might be concerned with lower-level details of managing a database . It is an executor of commands usually triggered by a Window Handling Object or a parent Business Object. It should not implement events of any type; the responsibility of \u201ecall-to-action\u201d belongs to the Window Handling Object. It does not reference any visual components (WPF); it does not display user-level information. When an unexpected result occurs inside of a function, the best practice would be to throw Exception instead of returning error-value. It should not handle Exceptions in try/catch blocks; in the catch blocks, it should always call \u201ethrow;\u201d after some action is performed such as Logging the error. Uses LoggerSink sparingly (best practice: not at all). Note *: * the code-examples used in section BusinessObject and Window Handling Object are code sequences from Production Feedback-Module (shortcut: PRM ) DataSet Definition A DataSet is a data container composed of tables (DataTables) that contain rows (DataRows), uses SQL queries to retrieve that data from the database, tracks changes to each columns and generated update/insert/delete statements transparently when required to write data back into the database. Each DataRow may have one of the following RowStates: New : the row was added to the dataSet and will be ignored on Save EditingNew : the row was already edited and it\u2019s prepared to be saved Modified : an existing row was modified NotModified : an existing row was retrieved from the db Deleted : the row was marked as deleted, will be deleted only at Save None : the row was not added to the collection; the row is detached For updateable DataSets, the tables must be arranged in the same order, in which the primary-key inserts are done. For the Delete operation, the DataSet will do the action in the reverse order. Window Handling Object Never call Override-Methods, because: these methods are in general called automatically from the framework, as a result of an action they are usually part of a sequence of actions (OnSave() is called after OnPreSave() \u2013 if the latter returned 0 \u2013 and if OnSave() returns 0, OnPostSave() is called) these methods are the equivalent of \"event handlers\", which should never be called directly; if the code sequence contained in the override method is needed, a common method should be written and called every time it is needed whenever an event has to be called, it means that the functionality behind the event should be extracted into a method; in this case, the method can be called from the event itself, as well as anywhere else, explicitly. Example : call WHO-method in override Method: public override void OnNew(UIElement sourceControl) { if (sourceControl == dgMaterial) { NewMaterial(); } } call BusinessObject-method from WHO-method: public virtual void NewMaterial() { var material = BusObj.NewMatRow(); if (material == null) return; } Order of execution: Event - WHO-method - BusObj. Do not call your BusinessObject-Method in a WHO override method. Do not write Business-Logic inside WHO methods.","title":"Introduction"},{"location":"documentation/introduction/#introduction","text":"","title":"Introduction"},{"location":"documentation/introduction/#module","text":"Each \u201ecomplete\u201d module has: a Window Handling Object WHO: specifies the behavior of the controls a BusinessObject busObj: data manipulation; direct access to the dataSet (and dataSet fields) at least one DataSet A Window Handling Object defines the behavior of the window itself and of the controls within it. It is the place where the \u201ecall-to-action\u201d happens, i.e. it can respond to event handlers of any type. It responds to various events triggered by the window or by the controls, it holds references to the controls and can modify their properties at any given time. It does not contain business logic functionality; it delegates the functionality to the Business Object. It is the component that is able to handle exceptions and decide how the exception is handled (show message to user, retry, fail silently, etc.) A Business Object is the part of the program that encodes the real-world business rules that determine how data can be created, stored, and changed . It is contrasted with the remainder of the software that might be concerned with lower-level details of managing a database . It is an executor of commands usually triggered by a Window Handling Object or a parent Business Object. It should not implement events of any type; the responsibility of \u201ecall-to-action\u201d belongs to the Window Handling Object. It does not reference any visual components (WPF); it does not display user-level information. When an unexpected result occurs inside of a function, the best practice would be to throw Exception instead of returning error-value. It should not handle Exceptions in try/catch blocks; in the catch blocks, it should always call \u201ethrow;\u201d after some action is performed such as Logging the error. Uses LoggerSink sparingly (best practice: not at all). Note *: * the code-examples used in section BusinessObject and Window Handling Object are code sequences from Production Feedback-Module (shortcut: PRM )","title":"Module"},{"location":"documentation/introduction/#dataset-definition","text":"A DataSet is a data container composed of tables (DataTables) that contain rows (DataRows), uses SQL queries to retrieve that data from the database, tracks changes to each columns and generated update/insert/delete statements transparently when required to write data back into the database. Each DataRow may have one of the following RowStates: New : the row was added to the dataSet and will be ignored on Save EditingNew : the row was already edited and it\u2019s prepared to be saved Modified : an existing row was modified NotModified : an existing row was retrieved from the db Deleted : the row was marked as deleted, will be deleted only at Save None : the row was not added to the collection; the row is detached For updateable DataSets, the tables must be arranged in the same order, in which the primary-key inserts are done. For the Delete operation, the DataSet will do the action in the reverse order.","title":"DataSet Definition"},{"location":"documentation/introduction/#window-handling-object","text":"Never call Override-Methods, because: these methods are in general called automatically from the framework, as a result of an action they are usually part of a sequence of actions (OnSave() is called after OnPreSave() \u2013 if the latter returned 0 \u2013 and if OnSave() returns 0, OnPostSave() is called) these methods are the equivalent of \"event handlers\", which should never be called directly; if the code sequence contained in the override method is needed, a common method should be written and called every time it is needed whenever an event has to be called, it means that the functionality behind the event should be extracted into a method; in this case, the method can be called from the event itself, as well as anywhere else, explicitly. Example : call WHO-method in override Method: public override void OnNew(UIElement sourceControl) { if (sourceControl == dgMaterial) { NewMaterial(); } } call BusinessObject-method from WHO-method: public virtual void NewMaterial() { var material = BusObj.NewMatRow(); if (material == null) return; } Order of execution: Event - WHO-method - BusObj. Do not call your BusinessObject-Method in a WHO override method. Do not write Business-Logic inside WHO methods.","title":"Window Handling Object"},{"location":"mkdocs/using-mkdocs/","text":"Using MkDocs To install the utilities, run the following command as administrator: choco install mkdocs To start the documentation in the browser, navigate in command prompt to the root folder of the documentation and run the command: mkdocs serve When the documentation is ready to deploy, stop the running server in the command prompt using Ctrl-C , then run the command: mkdocs build Now the documentation can be pushed on github! In GitHub Desktop, commit the changes, then don't forget to also click on Push in the upper right corner","title":"MkDocs"},{"location":"mkdocs/using-mkdocs/#using-mkdocs","text":"To install the utilities, run the following command as administrator: choco install mkdocs To start the documentation in the browser, navigate in command prompt to the root folder of the documentation and run the command: mkdocs serve When the documentation is ready to deploy, stop the running server in the command prompt using Ctrl-C , then run the command: mkdocs build Now the documentation can be pushed on github! In GitHub Desktop, commit the changes, then don't forget to also click on Push in the upper right corner","title":"Using MkDocs"}]}